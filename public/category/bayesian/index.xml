<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bayesian | </title>
    <link>https://stablemarkets.netlify.app/category/bayesian/</link>
      <atom:link href="https://stablemarkets.netlify.app/category/bayesian/index.xml" rel="self" type="application/rss+xml" />
    <description>Bayesian</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 03 Dec 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://stablemarkets.netlify.app/media/icon_hu56437e0029043a6980b2632a303bfe7c_22443_512x512_fill_lanczos_center_3.png</url>
      <title>Bayesian</title>
      <link>https://stablemarkets.netlify.app/category/bayesian/</link>
    </image>
    
    <item>
      <title>Bayesian Sequential Decision-Making with Informative Timing</title>
      <link>https://stablemarkets.netlify.app/post/post6/bayeseq_aml/</link>
      <pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://stablemarkets.netlify.app/post/post6/bayeseq_aml/</guid>
      <description>
&lt;script src=&#34;https://stablemarkets.netlify.app/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;This post is a brief summary of highlights from our &lt;a href=&#34;https://arxiv.org/abs/2211.16393&#34;&gt;recent working paper&lt;/a&gt; titled “Bayesian Semiparametric Model for Sequential Treatment Decisions with Informative Timing.” It’s part of a series of projects on developing robust Bayesian nonparametric models for sequential decision making in a variety of complex settings. In this case, we deal with a situation in which the decisions are informatively timed - with a motivating application in chemotherapy treatments for pediatric acute myeloid leukemia (AML).&lt;/p&gt;
&lt;p&gt;This is partially funded by a &lt;a href=&#34;https://www.pcori.org/research-results/2022/statistical-methods-optimizing-dynamic-patient-level-treatment-and-monitoring-strategies&#34;&gt;PCORI grant&lt;/a&gt; grant awarded earlier this year (2022).&lt;/p&gt;
&lt;div id=&#34;setting-and-problem&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Setting and Problem&lt;/h1&gt;
&lt;p&gt;Chemotherapy treatment in AML is not “one and done” but involves making a sequence of treatment decisions over time, with each subsequent treatment decision depending on how the patient has responded to previous treatments and the evolution of their disease process. There are many chemo agents. This work focuses on understanding the effect of anthracyclines (ACT) in particular on survival. ACT is known to be effective in certain cases, but it can also lead to cardiotoxicity and subsequent early death.&lt;/p&gt;
&lt;p&gt;This presents clinicians with a risk-reward tradeoff - trting too aggressively or too conservatively with ACT may reduce survival. To help inform decisions, an echocardiogram is done to help decide if the heart is healthy enough to tolerate ACT. Clinicians follow various rules of thumb in practice. For instance: withholding ACT if a patient’s current ejection fraction (measured via echocardiogram) falls below some absolute threshold (eg 50%) or if it declines more than some relative (e.g. declines more than 20% from time of enrollment). Briefly, ejection fraction (EF) is the proportion of blood that is pumped out of the heart’s left ventricle during a beat. In healthy individuals, this is fairly high (from 50-75%) but can be lower among patients with cardiotoxicity. These treatment rules are “dynamic” in that ACT is decided based on evolving ejection fraction. This is in contrast to static rules such as “always treat with ACT”, “never treat with ACT” or “alternate ACT” - regardless of EF. The goal is to develop a strategy for estimating survival rates under various hypothetical ACT assignment rules. If we have such a method, we could evaluate the efficacy of the various rules of thumb employed in clinics and arrive at a more data-driven approach.&lt;/p&gt;
&lt;p&gt;Luckily, using data from the Phase III AAML1031 trial, we can estimate effects of such ACT treatment strategies on survival. In the trial, patients move through a sequence of 4 chemo courses. Ahead of each course, an echo is conducted &amp;amp; used to decide ACT inclusion.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;challenges&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Challenges&lt;/h1&gt;
&lt;p&gt;There are many impediments to valid statistical estimation. 1) ACT is not randomized in the trial but informed by time-varying features such as EF. We need to adjust for such features to get an apples-to-apples comparison of different ACT rules. 2) Some patients die or drop out before ever completing the sequence. In the latter case, we are left with incomplete survival information. 3) Treatment courses are not initiated at pre-fixed times, but depending on when subjects recover from the previous chemotherapy course.&lt;/p&gt;
&lt;p&gt;This last point suggests that the waiting times between treatments are potential confounders (e.g. slower recovery after previous treatment may inform subsequent treatment and drive survival) - quite a unique type of time-varying confounding which requires modifications to the usual g-computation algorithm for sequential treatments&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;a-bayesian-semiparametric-method&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;A Bayesian Semiparametric Method&lt;/h1&gt;
&lt;p&gt;We model the causal structure using a non-homogenous continuous-time transition process. After each course, patients can transition into a state of subsequent death or transition into a state of subsequent treatment - whichever comes first - in continuous-time. These process is characterized by a pair of transition probabilities: one pair for each treatment course. We use Bayesian semiparametric hazard models to estimate the transition probabilities at each stage as a function of features available at the start of this course.&lt;/p&gt;
&lt;p&gt;Causal effects of certain rules are computed by simulating from the transition process under a specified rule and computing the proportion of simulated subjects who survive past a certain time point (e.g. 3 years, if we want to compute 3-year survival).&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Sample versus Population ATE in Bayesian Caual Estimation</title>
      <link>https://stablemarkets.netlify.app/post/post5/sate-v-pate/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://stablemarkets.netlify.app/post/post5/sate-v-pate/</guid>
      <description>
&lt;script src=&#34;https://stablemarkets.netlify.app/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Writing up a quick post to clarify a point of common confusion when doing posterior inference for causal effects. All causal inference (regardless of statistical modeling paradigm in consideration) begins with expressing the target estimand in terms of unobservables (e.g. potential outcomes) and linking them to observed data with ``identification assumptions.’’ Two common estimands (which are often confused) are the population level average treatment effect (ATE) and the sample level ATE. These are two very different estimands and inferential procedures therefore differ for each. Yet, they seem to be confused with each other quite often. This post clarifies the distinction.&lt;/p&gt;
&lt;p&gt;Suppose we have a binary treatment &lt;span class=&#34;math inline&#34;&gt;\(A_i\in\{0,1\}\)&lt;/span&gt;, outcome &lt;span class=&#34;math inline&#34;&gt;\(Y_i\)&lt;/span&gt;, and a set of pre-treatment confounders &lt;span class=&#34;math inline&#34;&gt;\(L_i\)&lt;/span&gt; for &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; independent subjects. Let the observed data be &lt;span class=&#34;math inline&#34;&gt;\(D = \{Y_i, A_i, L_i \}_{i=1}^n\)&lt;/span&gt;. Much of the following can be found in &lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1002/sim.8761&#34;&gt;Oganisian &amp;amp; Roy, 2020&lt;/a&gt; and &lt;a href=&#34;https://projecteuclid.org/journals/statistical-science/volume-33/issue-2/Causal-Inference-A-Missing-Data-Perspective/10.1214/18-STS645.full&#34;&gt;Ding and Li, 2018&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;the-population-level-ate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The population-level ATE&lt;/h2&gt;
&lt;p&gt;The population-level in potential outcome notation can be expressed as
&lt;span class=&#34;math display&#34;&gt;\[ \Psi = E[Y^1 - Y^0] \]&lt;/span&gt;
Under certain identification assumptions, this is identified via the g-formula:
&lt;span class=&#34;math display&#34;&gt;\[ \Psi(\mu, P_L) = \int_{\mathcal{L}} \Big( \mu(1, l)- \mu(0, l)\Big) dP_L(l) \]&lt;/span&gt;
Where &lt;span class=&#34;math inline&#34;&gt;\(\mu(a, l) = E[Y\mid A=a, L=l]\)&lt;/span&gt; is the outcome regression function. Here the notation &lt;span class=&#34;math inline&#34;&gt;\(\Psi(\mu, P_L)\)&lt;/span&gt; makes it explicit that the causal estimand is a function of two unknowns: the unknown regression function and the unknown confounder distribution. If we have estimates of these objects, &lt;span class=&#34;math inline&#34;&gt;\(\hat \mu\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\hat P_L\)&lt;/span&gt;, frequentist inference can be done via a plug-in estimator
&lt;span class=&#34;math display&#34;&gt;\[ \hat\Psi(\hat \mu, \hat P_L) = \int_{\mathcal{L}} \Big( \hat\mu(1, l)- \hat\mu(0, l)\Big) d\hat P_L(l) \]&lt;/span&gt;
For example, if we could fit a standard GLM with some inverse-link function,&lt;span class=&#34;math inline&#34;&gt;\(g^{-1}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\hat\mu(a, l) = g^{-1}(\hat \beta_0 + \hat \beta_1 A + \hat L&amp;#39;\beta_2)\)&lt;/span&gt;. Typically we use the empirical distribution for the confounder distribution estimate, &lt;span class=&#34;math inline&#34;&gt;\(\hat P_L(l) = \sum_{i=1}^n \frac{1}{n} I(L_i = l)\)&lt;/span&gt;. So we have
&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
\hat\Psi(\hat \mu, \hat P_L) &amp;amp; = \int_{\mathcal{L}} \Big( \hat\mu(1, l)- \hat\mu(0, l)\Big) d\hat P_L(l) \\
                              &amp;amp; = \sum_{i=1}^n \frac{1}{n} \Big( \hat\mu(1, L_i)- \hat\mu(0, L_i)\Big) \\
\end{align*}
\]&lt;/span&gt;
That is, we end up average the difference in the mean function,&lt;span class=&#34;math inline&#34;&gt;\(\hat\mu(a, l)\)&lt;/span&gt;, under both treatments over the empirical distribution of confounders. Typically bootstrap is used to compute interval estimates for the population ATE.&lt;/p&gt;
&lt;p&gt;Bayesian inference for this quantity is also straightforward: obtain the &lt;span class=&#34;math inline&#34;&gt;\(m^{th}\)&lt;/span&gt; posterior draw of the regression function &lt;span class=&#34;math inline&#34;&gt;\(\mu^{(m)}(a,l)\)&lt;/span&gt; under your favorite Bayesian model (a Generalized Linear Model, Gaussian process, Dirichlet Process, BART, etc). Then obtain the &lt;span class=&#34;math inline&#34;&gt;\(m^{th}\)&lt;/span&gt; posterior draw of the confounder distribution. It is common to use the ``Bayesian Bootstrap’’ for this - a Bayesian analogue of the empirical distribution: &lt;span class=&#34;math inline&#34;&gt;\(P_L^{(m)}(l) = \sum_{i=1}^n \gamma_i^{(m)} I(L_i = l)\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\((\gamma_1^{(m)}, \gamma_2^{(m)}, \dots, \gamma_n^{(m)}) \sim Dir(1_n)\)&lt;/span&gt; are drawn froma Dirichlet Distribution. Then the posterior draw of the population-level ATE is
&lt;span class=&#34;math display&#34;&gt;\[
\begin{align*}
\Psi(\mu^{(m)}, P_L^{(m)}) &amp;amp; = \int_{\mathcal{L}} \Big(\mu^{(m)}(1, l)-\mu^{(m)}(0, l)\Big) d P_L^{(m)}(l) \\
                           &amp;amp; = \sum_{i=1}^n \gamma_i\Big(\mu^{(m)}(1, L_i)-\mu^{(m)}(0, L_i)\Big) \\
\end{align*}
\]&lt;/span&gt;
Again, we are taking a weighted average of the difference in the mean function draw, &lt;span class=&#34;math inline&#34;&gt;\(\mu^{(m)}(a, l)\)&lt;/span&gt;, under each intervention. Under the Bayesian bootstrap, the posterior expectation of each &lt;span class=&#34;math inline&#34;&gt;\(\gamma_i\)&lt;/span&gt; is 1/n - so you think can think of this as being centered around the empirical distribution. Doing this for &lt;span class=&#34;math inline&#34;&gt;\(m=1,2,\dots, M\)&lt;/span&gt; we get a set of posterior draws for the population ATE which can be used for point and interval estimation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-sample-level-ate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The sample-level ATE&lt;/h2&gt;
&lt;p&gt;Letting &lt;span class=&#34;math inline&#34;&gt;\(\textbf{Y}^m = \{ Y_i^{1-A_i} \}_{i=1}^n\)&lt;/span&gt; be the set of missing counterfactuals for the patients in the sample. The sample-level ATE is given by
&lt;span class=&#34;math display&#34;&gt;\[ \psi(\textbf{Y}^m) = \frac{1}{n} \sum_{i=1}^n (Y_i^1 - Y_i^0) \]&lt;/span&gt;
This is a very different quantity from the population-level estimand
&lt;span class=&#34;math display&#34;&gt;\[ \Psi(\mu, P_L) = \int_{\mathcal{L}} \Big( \mu(1, l)- \mu(0, l)\Big) dP_L(l) \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The uncertainty in the population-level ATE, &lt;span class=&#34;math inline&#34;&gt;\(\Psi(\mu, P_L)\)&lt;/span&gt;, is due to uncertainty about the unknown regression function, &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;, and confounder distribution, &lt;span class=&#34;math inline&#34;&gt;\(P_L\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The uncertainty in the sample-level estimand is due to uncertainty about the missing counterfactuals, &lt;span class=&#34;math inline&#34;&gt;\(\textbf{Y}^m\)&lt;/span&gt;. After all, under SUTVA, we only observe &lt;span class=&#34;math inline&#34;&gt;\(Y_i^{A_i}\)&lt;/span&gt; while &lt;span class=&#34;math inline&#34;&gt;\(Y_i^{1-A_i}\)&lt;/span&gt; is unobserved for subject with assignment &lt;span class=&#34;math inline&#34;&gt;\(A_i\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Bayesian solutions differ accordingly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To do posterior inference for the population-level ATE, we must draw the unknonwn regression function and confounder distributions from the posterior, &lt;span class=&#34;math inline&#34;&gt;\(f(\mu, P_L \mid D)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;To do posterior inference for the sample-level ATE, we must draw the unknown counterfactuals &lt;span class=&#34;math inline&#34;&gt;\(Y_i^{1-A_i}\)&lt;/span&gt; from the posterior &lt;span class=&#34;math inline&#34;&gt;\(f( \{ Y_i^{1-A_i} \}_{i=1}^n \mid D)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That last bullet is Bayesian inference for causal effects as originally described by Donald Rubin. While &lt;span class=&#34;math inline&#34;&gt;\(\Psi\)&lt;/span&gt; is identifiable, &lt;span class=&#34;math inline&#34;&gt;\(\psi\)&lt;/span&gt; is not identifiable except up to a sensitivity parameter. To show this, apply Bayes’ rule:
&lt;span class=&#34;math display&#34;&gt;\[ f( \{ Y_i^{1-A_i} \}_{i=1}^n \mid D) \propto f_A(A_i \mid L_i, Y_i^{A_i}, Y_i^{1-A_i} ) f_*(Y^A_i, Y_i^{1-A_i}\mid A_i, L_i) f_L(L_i) \]&lt;/span&gt;
if the usual ignorability holds (due to say a randomized treatment) - i.e. &lt;span class=&#34;math inline&#34;&gt;\(Y^1, Y^0 \perp A \mid L\)&lt;/span&gt; - the selection mechanism no longer depends on potential outcomes: &lt;span class=&#34;math display&#34;&gt;\[f_A(A_i \mid L_i, Y_i^{A_i}, Y_i^{1-A_i} ) = f_A(A_i \mid L_i )\]&lt;/span&gt;
and, along with &lt;span class=&#34;math inline&#34;&gt;\(f_L\)&lt;/span&gt; can be dropped while maintaining proportionality. But the crucial thing here is that the remaining joint distribution &lt;span class=&#34;math inline&#34;&gt;\(f_*(Y^A_i, Y_i^{1-A_i}\mid A_i, L_i)\)&lt;/span&gt; is  - we never observe both potential outcomes for subject &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;. This complicates sample-level inference. We could still make inferences. For instance, by invoking de Finetti, we could model it as &lt;span class=&#34;math inline&#34;&gt;\(N_2(Y_i^{A_i}, Y_i^{1-A_i}\mid A_i, L_i; \eta, \Sigma ) p(\eta)p(\Sigma)\)&lt;/span&gt;. Where &lt;span class=&#34;math inline&#34;&gt;\(N_2\)&lt;/span&gt; indicates a bivariate normal distribution with mean vector &lt;span class=&#34;math inline&#34;&gt;\(\eta\)&lt;/span&gt; and 2x2 covariance matrix, &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt;. But the off-diagonal terms of &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt;, $ Cov( Y_i^{A_i}, Y_i^{1-A_i} ) $, cannot be learned from data. Thus we call it a sensitivity parameter. The posterior is still defined, but will be completely driven by the prior &lt;span class=&#34;math inline&#34;&gt;\(p(\Sigma)\)&lt;/span&gt;. Thus, the sample-level effect is significantly more complicated .&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Specifying Accelerated Failure Time Models in STAN</title>
      <link>https://stablemarkets.netlify.app/post/post2/specifying-accelerated-failure-time-models-in-stan/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://stablemarkets.netlify.app/post/post2/specifying-accelerated-failure-time-models-in-stan/</guid>
      <description>
&lt;script src=&#34;https://stablemarkets.netlify.app/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;This post is an add-on to my &lt;a href=&#34;https://stablemarkets.netlify.com/post/post1/bayesian-survival-analysis-with-data-augmentation/&#34;&gt;previous post&lt;/a&gt; about augmented gibbs sampling for censored survival times. If you’re not a complete maniac like me, then you probably don’t want to code your own sampler from scratch like I did in that previous post. Luckily you don’t have to because you can easily specify that same model in &lt;a href=&#34;https://mc-stan.org/users/interfaces/rstan&#34;&gt;Stan&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s start with simulating some randomly censored data from a Weibull model. In this case, we just include a binary indicator and are interested in characterizing survival between these two groups.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)

n &amp;lt;- 1000

# simulate covariates (just a binary treatment indicator)
A &amp;lt;- rbinom(n, 1, .5)
X &amp;lt;- model.matrix(~ A)

# true parameters
true_beta &amp;lt;- (1/2)*matrix(c(-1/3, 2), ncol=1)
true_mu &amp;lt;- X %*% true_beta

true_sigma &amp;lt;- 1

true_alpha &amp;lt;- 1/true_sigma
true_lambda &amp;lt;- exp(-1*true_mu*true_alpha)

# simulate censoring and survival times
survt = rweibull(n, shape=true_alpha, scale = true_lambda) 
cent = rweibull(n, shape=true_alpha, scale = true_lambda)

## observed data:
#censoring indicator
delta &amp;lt;- cent &amp;lt; survt
survt[delta==1] &amp;lt;- cent[delta==1] # censor survival time.

# count number of missing/censored survival times
n_miss &amp;lt;- sum(delta)

d_list &amp;lt;- list(N_m = n_miss, N_o = n - n_miss, P=2, # number of betas
               # data for censored subjects
               y_m=survt[delta==1], X_m=X[delta==1,],
               # data for uncensored subjects
               y_o=survt[delta==0], X_o=X[delta==0,])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The list &lt;code&gt;d_list&lt;/code&gt; is what we’ll eventually feed to Stan. Below is the Stan model for Weibull distributed survival times. Note in the transformed parameters block we specify the canonical accelerated failure time (AFT) parameterization - modeling the scale as a function of the shape parameter, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;, and covariates.&lt;/p&gt;
&lt;p&gt;In the model block, we specify the likelihood as the Weibull density for uncensored subjects, and then augment the likelihood with evaluations from the Weibull survival function (&lt;code&gt;_lccdf&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The generated quantities block transforms the parameters to get posterior draws of the hazard ratio (as specified in my &lt;a href=&#34;https://stablemarkets.netlify.com/post/post1/bayesian-survival-analysis-with-data-augmentation/&#34;&gt;previous post&lt;/a&gt; ) as well as posterior draws of the survival function.&lt;/p&gt;
&lt;pre class=&#34;stan&#34;&gt;&lt;code&gt;data {
  int&amp;lt;lower=0&amp;gt; P; // number of beta parameters
  
  // data for censored subjects
  int&amp;lt;lower=0&amp;gt; N_m;
  matrix[N_m,P] X_m;
  vector[N_m] y_m;
  
  // data for observed subjects
  int&amp;lt;lower=0&amp;gt; N_o;
  matrix[N_o,P] X_o;
  real y_o[N_o];
}

parameters {
  vector[P] beta;                
  real&amp;lt;lower=0&amp;gt; alpha; // Weibull Shape      
}

transformed parameters{
  // model Weibull rate as function of covariates
  vector[N_m] lambda_m;
  vector[N_o] lambda_o;
  
  // standard weibull AFT re-parameterization
  lambda_m = exp((X_m*beta)*alpha);
  lambda_o = exp((X_o*beta)*alpha);
}

model {
  beta ~ normal(0, 100);
  alpha ~ exponential(1);
  
  // evaluate likelihood for censored and uncensored subjects
  target += weibull_lpdf(y_o | alpha, lambda_o);
  target += weibull_lccdf(y_m | alpha, lambda_m);
}


// generate posterior quantities of interest
generated quantities{
  vector[1000] post_pred_trt;
  vector[1000] post_pred_pbo;
  real lambda_trt; 
  real lambda_pbo; 
  real hazard_ratio;
  
  // generate hazard ratio
  lambda_trt = exp((beta[1] + beta[2])*alpha ) ;
  lambda_pbo = exp((beta[1])*alpha ) ;
  
  hazard_ratio = exp(beta[2]*alpha ) ;
  
  // generate survival times (for plotting survival curves)
  for(i in 1:1000){
    post_pred_trt[i] = weibull_rng(alpha,  lambda_trt);
    post_pred_pbo[i] = weibull_rng(alpha,  lambda_pbo);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Stan model specified above is stored in an object called &lt;code&gt;weibull_mod&lt;/code&gt;, which is called below in &lt;code&gt;sampling()&lt;/code&gt;. The code below samples from the posterior and outputs posterior draws of the hazard and predicted survival times.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;weibull_fit &amp;lt;- sampling(weibull_mod,
                data = d_list, 
                chains = 1, iter=20000, warmup=19000, save_warmup=F,
                pars= c(&amp;#39;hazard_ratio&amp;#39;,&amp;#39;post_pred_trt&amp;#39;,&amp;#39;post_pred_pbo&amp;#39;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## SAMPLING FOR MODEL &amp;#39;80acc0f9293b946800a710dd7f5e211c&amp;#39; NOW (CHAIN 1).
## Chain 1: 
## Chain 1: Gradient evaluation took 0.000172 seconds
## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.72 seconds.
## Chain 1: Adjust your expectations accordingly!
## Chain 1: 
## Chain 1: 
## Chain 1: Iteration:     1 / 20000 [  0%]  (Warmup)
## Chain 1: Iteration:  2000 / 20000 [ 10%]  (Warmup)
## Chain 1: Iteration:  4000 / 20000 [ 20%]  (Warmup)
## Chain 1: Iteration:  6000 / 20000 [ 30%]  (Warmup)
## Chain 1: Iteration:  8000 / 20000 [ 40%]  (Warmup)
## Chain 1: Iteration: 10000 / 20000 [ 50%]  (Warmup)
## Chain 1: Iteration: 12000 / 20000 [ 60%]  (Warmup)
## Chain 1: Iteration: 14000 / 20000 [ 70%]  (Warmup)
## Chain 1: Iteration: 16000 / 20000 [ 80%]  (Warmup)
## Chain 1: Iteration: 18000 / 20000 [ 90%]  (Warmup)
## Chain 1: Iteration: 19001 / 20000 [ 95%]  (Sampling)
## Chain 1: Iteration: 20000 / 20000 [100%]  (Sampling)
## Chain 1: 
## Chain 1:  Elapsed Time: 12.2212 seconds (Warm-up)
## Chain 1:                1.03363 seconds (Sampling)
## Chain 1:                13.2548 seconds (Total)
## Chain 1:&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;post_draws&amp;lt;-extract(weibull_fit)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below we plot posterior distribution of the hazard ratio. The red line indicates the true value under which we generated the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hist(post_draws$hazard_ratio,
     xlab=&amp;#39;Hazard Ratio&amp;#39;, main=&amp;#39;Hazard Ratio Posterior Distribution&amp;#39;)
abline(v=exp(-1*true_beta[2,1]*true_alpha), col=&amp;#39;red&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stablemarkets.netlify.app/post/post2/2019-03-09-specifying-accelerated-failure-time-models-in-stan_files/figure-html/plot_hazard_ratio-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(post_draws$hazard_ratio)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.3658342&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(post_draws$hazard_ratio, probs = c(.025, .975))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      2.5%     97.5% 
## 0.3039049 0.4376196&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below we plot the survival functions. Note these results are very similar to the augmented sampler coded in the previous post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(survfit(Surv(survt, 1-delta) ~ A ), col=c(&amp;#39;black&amp;#39;,&amp;#39;blue&amp;#39;),
     xlab=&amp;#39;Time&amp;#39;,ylab=&amp;#39;Survival Probability&amp;#39;, conf.int=T)

for(i in 1:1000){
  trt_ecdf &amp;lt;- ecdf(post_draws$post_pred_trt[i,])
  curve(1 - trt_ecdf(x), from = 0, to=4, add=T, col=&amp;#39;gray&amp;#39;)
  
  pbo_ecdf &amp;lt;- ecdf(post_draws$post_pred_pbo[i,])
  curve(1 - pbo_ecdf(x), from = 0, to=4, add=T, col=&amp;#39;lightblue&amp;#39;)
}

lines(survfit(Surv(survt, 1-delta) ~ A ), col=c(&amp;#39;black&amp;#39;,&amp;#39;blue&amp;#39;), add=T,
      conf.int=T)

legend(&amp;#39;topright&amp;#39;, 
       legend = c(&amp;#39;KM Curve and Intervals (TRT)&amp;#39;,
                  &amp;#39;Posterior Survival Draws (TRT)&amp;#39;,
                  &amp;#39;KM Curve and Intervals (PBO)&amp;#39;,
                  &amp;#39;Posterior Survival Draws (PBO)&amp;#39;),
       col=c(&amp;#39;black&amp;#39;,&amp;#39;gray&amp;#39;,&amp;#39;blue&amp;#39;,&amp;#39;lightblue&amp;#39;), 
       lty=c(1,0,1,0), pch=c(NA,15,NA,15), bty=&amp;#39;n&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stablemarkets.netlify.app/post/post2/2019-03-09-specifying-accelerated-failure-time-models-in-stan_files/figure-html/plot_survival-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
