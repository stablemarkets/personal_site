name = "Treatment Option"
) +
labs(x = "Time", y = "Subject", shape = "") +
theme_minimal()
d$id <- factor(1:nrow(d), levels = rev(sort(unique(d$id))))
ggplot(d[1:20,], aes(y = factor(id))) +
geom_segment(aes(x = 0, xend = Y, yend = factor(id))) +
# Event/censored marker at end of line
geom_point(aes(x = Y, shape = factor(delta)), size = 3) +
# Filled square at A_time, color by A
geom_point(
aes(x = time_A, fill = factor(A)),
shape = 22,  # 22 = filled square with fill color
size = 3,
color = "black" # Outline color for the square, optional
) +
scale_shape_manual(
values = c("0" = 1, "1" = 4),  # 1=open circle, 4=X
labels = c("Event", "Censored")
) +
scale_fill_manual(
values = c("0" = "orange", "1" = "royalblue"),
labels = c("A = 0", "A = 1"),
name = "Treatment Option"
) +
labs(x = "Time", y = "Subject", shape = "") +
geom_vline(xintercept = 5, linetype = "dashed", color = "red") +
theme_minimal()
set.seed(21)
d = sim_data(n=500)
d$delta=1 ## in this example, all patients eventually have event (no censoring)
d$id_plot <- factor(id, levels = rev(sort(unique(d$id))))
d
sim_data = function(n=300){
X = rbinom(n, 1, .5)
time_A = rexp(n, .4*X + .2*(1-X))
A = rbinom(n, 1, plogis( .1 + 2*X ) )
time_event= rexp(n, .2 + 1*X + 0*A ) ## assuming zero effect
data = data.frame(id=1:n,
Y= time_event + time_A,
A = A,
X = X,
time_A = time_A)
return(data)
}
set.seed(21)
d = sim_data(n=500)
d$delta=1 ## in this example, all patients eventually have event (no censoring)
d$id_plot <- factor(id, levels = rev(sort(unique(d$id))))
d$id_plot <- factor(d$id, levels = rev(sort(unique(d$id))))
ggplot(d[1:20,], aes(y = factor(id))) +
geom_segment(aes(x = 0, xend = Y, yend = factor(id_plot))) +
# Event/censored marker at end of line
geom_point(aes(x = Y, shape = factor(delta)), size = 3) +
# Filled square at A_time, color by A
geom_point(
aes(x = time_A, fill = factor(A)),
shape = 22,  # 22 = filled square with fill color
size = 3,
color = "black" # Outline color for the square, optional
) +
scale_shape_manual(
values = c("0" = 1, "1" = 4),  # 1=open circle, 4=X
labels = c("Event", "Censored")
) +
scale_fill_manual(
values = c("0" = "orange", "1" = "royalblue"),
labels = c("A = 0", "A = 1"),
name = "Treatment Option"
) +
labs(x = "Time", y = "Subject", shape = "") +
geom_vline(xintercept = 5, linetype = "dashed", color = "red") +
theme_minimal()
d$id_plot <- factor(d$id, levels = rev(sort(unique(d$id))))
ggplot(d[1:20,], aes(y = factor(id_plot))) +
geom_segment(aes(x = 0, xend = Y, yend = factor(id_plot))) +
# Event/censored marker at end of line
geom_point(aes(x = Y, shape = factor(delta)), size = 3) +
# Filled square at A_time, color by A
geom_point(
aes(x = time_A, fill = factor(A)),
shape = 22,  # 22 = filled square with fill color
size = 3,
color = "black" # Outline color for the square, optional
) +
scale_shape_manual(
values = c("0" = 1, "1" = 4),  # 1=open circle, 4=X
labels = c("Event", "Censored")
) +
scale_fill_manual(
values = c("0" = "orange", "1" = "royalblue"),
labels = c("A = 0", "A = 1"),
name = "Treatment Option"
) +
labs(x = "Time", y = "Subject", shape = "") +
geom_vline(xintercept = 5, linetype = "dashed", color = "red") +
theme_minimal()
par(mfrow=c(1,2))
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Kaplan-Meier for Observed Time to Death by initiated treatment',
xlab='Time since baseline',ylab='Proportion Alive',conf.int = F)
## time to treatment initiation among those who got treatment 1 versus 0
plot(survfit(Surv(d$time_A, d$delta) ~ d$A ),mark.time = T,
main='Kaplan-Meier for Observed Time to Treatment Initiation',
xlab='Time since baseline',ylab='Proportion untreated',conf.int = F)
max(d$Y[d$A==1])
max(d$Y[d$A==0])
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,col=c('black','red')
main='Kaplan-Meier for Observed Time to Death by initiated treatment',
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,col=c('black','red'),
main='Kaplan-Meier for Observed Time to Death by initiated treatment',
xlab='Time since baseline',ylab='Proportion Alive',conf.int = F)
legend('topright',
col=c('black','red'),
legend = c('Treatment 1', 'Treatment 0') )
legend('topright',
col=c('black','red'),lty=c(1,1),
legend = c('Treatment 1', 'Treatment 0') )
par(mfrow=c(1,2))
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,col=c('black','red'),
main='Kaplan-Meier for Observed Time to Death by initiated treatment',
xlab='Time since baseline',ylab='Proportion Alive',conf.int = F)
legend('topright',
col=c('black','red'),lty=c(1,1),
legend = c('Treatment 1', 'Treatment 0') )
## time to treatment initiation among those who got treatment 1 versus 0
plot(survfit(Surv(d$time_A, d$delta) ~ d$A ),mark.time = T, col=c('black','red'),
main='Kaplan-Meier for Observed Time to Treatment Initiation',
xlab='Time since baseline',ylab='Proportion untreated',conf.int = F)
View(ppd1)
seq(K_star, tau, by=K_star)
cuts_st = c(0, cuts[1:(length(cuts)-1)])
cuts_end = cuts
cbind(cuts_st, cuts_end)
int_start = c(0, cuts[1:(length(cuts)-1)])
int_end = cuts
cbind(int_start, int_end)
ppd1$int_start = int_start[as.numeric(ppd1$timeInt)]
ppd1$int_end = int_end[as.numeric(ppd1$timeInt)]
View(ppd1)
ppd1[, c('obj','timeInt','int_start','int_end')]
ppd1[, c('obj','timeInt','int_start','int_end','Y','y','A','time_A','X','A1')]
cbind(int_start, int_end)
?head
head( ppd1[, c('obj','timeInt','int_start','int_end','Y','y','A','time_A','X','A1')], n=20 )
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]), ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time', ylab='Proportion Event-Free',
main = 'Adjusted Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1), col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Kaplan-Meier for Observed Time to Fracture',
xlab='Time since baseline, months',ylab='Proportion without fracture',conf.int = F)
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier for Observed Time to Fracture',
xlab='Time since baseline, months',ylab='Proportion without fracture',conf.int = F)
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]), ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time', ylab='Proportion Event-Free',
main = 'Adjusted Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1), col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier for Observed Time to Fracture',
xlab='Time since baseline, months',ylab='Proportion without fracture',conf.int = F)
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]),
ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time', ylab='Proportion Event-Free',
main = 'Adjusted Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1),
col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier for Observed Time to Fracture',
xlab='Time since baseline, months',ylab='Proportion without fracture',
conf.int = F, col=c('black','red'))
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]),
ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time since baseline, months', ylab='Proportion Event-Free',
main = 'Adjusted Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1),
col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier Estimates',
xlab='Time since baseline, months',ylab='Proportion Event-Free',
conf.int = F, col=c('black','red'))
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]),
ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time since baseline', ylab='Proportion Event-Free',
main = 'Adjusted Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1),
col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier Estimates',
xlab='Time since baseline',ylab='Proportion Event-Free',
conf.int = F, col=c('black','red'))
par(mfrow=c(1,2))
plot(c(0,cuts), c(1,d_haz$cum_surv[d_haz$S==1]),
ylim=c(0,1), xlim=c(0, 50), type='o',
xlab='Time since baseline', ylab='Proportion Event-Free',
main = 'Adjusted Causal Estimates Under Each Strategy')
points(c(0, cuts), c(1,d_haz$cum_surv[d_haz$S==0]), ylim=c(0,1),
col='red', type='o')
plot(survfit(Surv(d$Y, d$delta) ~ d$A ),mark.time = T,
main='Unadjusted Kaplan-Meier Estimates',
xlab='Time since baseline',ylab='Proportion Event-Free',
conf.int = F, col=c('black','red'))
ppd1[, c('obj','timeInt', 'int_start','int_end','A1','haz_ck', 'haz_not_ck','w_cen')]
head(ppd1[, c('obj','timeInt', 'int_start','int_end','A1','haz_ck', 'haz_not_ck','w_cen')], n=20)
remotes::install_github("LnnnnYW/BayCauRETM")
library(BayCauRETM)
## 1. Simulate toy data: 4 subjects Ã— 3 intervals
set.seed(123)
toy <- data.frame(
pat_id = rep(1:4, each = 3),
k_idx  = rep(1:3, 4),
Y_obs  = rpois(12, 1),
T_obs  = rbinom(12, 1, 0.3),
A      = rbinom(12, 1, 0.4)
)
View(toy)
## 2. Pre-process: add lags (Y_prev, T_prev) and fill missing intervals
pre <- preprocess_data(toy, K = 3)
View(pre)
View(pre)
pre
pre$processed_df
?preprocess_data
git_causal_recur
fit_causal_recur
preprocess_data
## 2. Pre-process: add lags (Y_prev, T_prev) and fill missing intervals
pre <- preprocess_data(toy, K = 3)
## 3. Fit Bayesian joint model (tiny MCMC just for illustration)
fit <- fit_causal_recur(
data       = pre$processed_df,
K          = 3,
formula_T  = T_obs ~ Y_prev + A + k_idx,
formula_Y  = Y_obs ~ Y_prev + A + k_idx,
prior      = list(
eta_beta  = 0, sigma_beta  = 1, rho_beta   = 0.5,
eta_gamma = 0, sigma_gamma = 1, rho_gamma  = 0.5),
num_chains = 1,
iter       = 200,      # increase for real analysis
verbose    = FALSE
)
pre$processed_df
## 3. Fit Bayesian joint model (tiny MCMC just for illustration)
fit <- fit_causal_recur(
data       = pre$processed_df,
K          = 3,
formula_T  = T_obs ~ Y_prev + A + k_idx,
formula_Y  = Y_obs ~ Y_prev + A + k_idx,
prior      = list(
eta_beta  = 0, sigma_beta  = 1, rho_beta   = 0.5,
eta_gamma = 0, sigma_gamma = 1, rho_gamma  = 0.5),
num_chains = 1,
iter       = 200,      # increase for real analysis
verbose    = TRUE
)
n=100
x = rnorm(n)
y = rbinom(n, 1, prob=plogis(1 + 1*x))
mod = glm(y ~ x, family=binomial('logit'))
mod$fitted.values
?boxplot
exp(3)
exp(6)
250 + 125
375/1000
.375*2*250
(1-.375)*(4/3)*375
.375*2*250
.375*2*250
(1-.375)*(4/3)*375
(1-.375)*(4)*125
.375*2*250 +
.375*2*250 +
(1-.375)*(4/3)*375 +
(1-.375)*(4)*125
.375*2 +
.375*2 +
(1-.375)*(4/3) +
(1-.375)*(4)
(.375*2 +
.375*2 +
(1-.375)*(4/3) +
(1-.375)*(4) )/4
.375*2*250
.375*2*250
(1-.375)*(4/3)*375
(1-.375)*(4)*125
(250+125) / (250+375)
(250+125) / 1000
pA1 = (250+125) / 1000
(.375*2 +
.375*2 +
(1-.375)*(4/3) +
(1-.375)*(4) )/4
.375*2*250
.375*2*250
(1-.375)*(4/3)*375
(1-.375)*(4)*125
pA1=1
pA1*2*250
pA1*2*250
(1-pA1)*(4/3)*375
(1-pA1)*(4)*125
pA1=1
pA0=1
pA1*2*250
pA1*2*250
(pA0)*(4/3)*375
(pA0)*(4)*125
pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125
pA1=.5
pA0=.5
pA1*2*250
pA1*2*250
(pA0)*(4/3)*375
(pA0)*(4)*125
pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125
pA1=.8
pA0=.2
pA1*2*250
pA1*2*250
(pA0)*(4/3)*375
(pA0)*(4)*125
pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125
(pA1*2 +
pA1*2 +
(pA0)*(4/3) +
(pA0)*(4) )/4
(pA1*2 +
pA1*2 +
(pA0)*(4/3) +
(pA0)*(4) )/1000
(pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125 )/1000
pA1 = (250+125) / 1000
pA1=1
pA0=1
pA1*2*250
pA1*2*250
(pA0)*(4/3)*375
(pA0)*(4)*125
pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125
(pA1*2*250 +
pA1*2*250 +
(pA0)*(4/3)*375 +
(pA0)*(4)*125 )/1000
sim_data = function(n, sim_truth = NULL){
L1 = rbinom(n, 1, .5)
L2 = rnorm(n, 0, 1)
A = rbinom(n, 1, plogis( -1 + 2*L1 + .5*L2  ) )
if(!is.null(sim_truth)){
A = rep(sim_truth[1], n)
}
Y = rbinom(n, 1, plogis( -1 + 1*L1 + .5*L2 + 1*A ) )
data = data.frame(id=1:n, L1, L2, A, Y)
if(!is.null(sim_truth)){
return(mean(Y))
}else{
return(data)
}
}
set.seed(1)
data = sim_data(1000)
diff_true = sim_data(1000000, sim_truth = 1) - sim_data(1000000, sim_truth = 0)
``
theta_hat = sum( data$A*data$Y / sum(data$A) - ((1-data$A)*data$Y)/sum( (1-data$A)) )
theta_hat
mean(data$Y[data$A==1]) - mean(data$Y[data$A==0]) ## should match theta_hat
## estimate treatment model, P( A = 1 | L )
trt_model = glm(data=data, formula = A ~ L1 + L2, family=binomial('logit'))
summary(trt_model)
## estimate pi(L_i) for each subject i
data$pi_hat = predict(trt_model, newdata = data, type = 'response')
## calculate weight, w_i
## calculate unstabilized weights
data$w = (data$A / data$pi_hat) + (1-data$A)/(1-data$pi_hat)
## compute different in causal effects via hajek estimator
diff_iptw = sum( data$A*data$w*data$Y / sum(data$A*data$w) -
((1-data$A)*data$w*data$Y)/sum( (1-data$A)*data$w) )
## calculate stabilized weights
data$w2 = ( (data$A * mean(data$A) )/ data$pi_hat) + ((1-data$A)*(1-mean(data$A))) /(1-data$pi_hat)
## calculate treatment effect via hajek estimator
diff_iptw_s = sum( data$A*data$w2*data$Y / sum(data$A*data$w2) -
((1-data$A)*data$w2*data$Y)/sum( (1-data$A)*data$w2) )
plot(data$w, data$w2, col=ifelse(data$A==1,'blue','gray'), xlim=c(0,10), ylim=c(0,10))
abline(0,1,col='red', lty=2)
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
hist(data$w, breaks=100, xlim=c(0,10))
outcome_mod = lm(data=data, Y ~ A, weights = w)
summary(outcome_mod)
outcome_mod = lm(data=data, Y ~ A, weights = w2)
summary(outcome_mod)
mean(data$w2)
mean(data$w)
mean(data$w[data$A==1])
mean(data$w[data$A==0])
sim_data = function(n, sim_truth = NULL){
L1 = rbinom(n, 1, .5)
L2 = rnorm(n, 0, 1)
A = rbinom(n, 1, plogis( -1 + 2*L1 + .5*L2  ) )
if(!is.null(sim_truth)){
A = rep(sim_truth[1], n)
}
Y = rbinom(n, 1, plogis( -1 + 1*L1 + .5*L2 + 1*A ) )
data = data.frame(id=1:n, L1, L2, A, Y)
if(!is.null(sim_truth)){
return(mean(Y))
}else{
return(data)
}
}
set.seed(1)
data = sim_data(1000)
diff_true = sim_data(1000000, sim_truth = 1) - sim_data(1000000, sim_truth = 0)
#------------------------------------------------------------------------------#
###------ Implement Unadjusted Estimator                               ------###
#------------------------------------------------------------------------------#
theta_hat = sum( data$A*data$Y / sum(data$A) - ((1-data$A)*data$Y)/sum( (1-data$A)) )
theta_hat
mean(data$Y[data$A==1]) - mean(data$Y[data$A==0]) ## should match theta_hat
#------------------------------------------------------------------------------#
###------ Implement Weighting Manually                                 ------###
#------------------------------------------------------------------------------#
## estimate treatment model, P( A = 1 | L )
trt_model = glm(data=data, formula = A ~ L1 + L2, family=binomial('logit'))
summary(trt_model)
## estimate pi(L_i) for each subject i
data$pi_hat = predict(trt_model, newdata = data, type = 'response')
## calculate weight, w_i
## calculate unstabilized weights
data$w = (data$A / data$pi_hat) + (1-data$A)/(1-data$pi_hat)
## compute different in causal effects via hajek estimator
diff_iptw = sum( data$A*data$w*data$Y / sum(data$A*data$w) -
((1-data$A)*data$w*data$Y)/sum( (1-data$A)*data$w) )
## calculate stabilized weights
data$w2 = ( (data$A * mean(data$A) )/ data$pi_hat) + ((1-data$A)*(1-mean(data$A))) /(1-data$pi_hat)
## calculate treatment effect via hajek estimator
diff_iptw_s = sum( data$A*data$w2*data$Y / sum(data$A*data$w2) -
((1-data$A)*data$w2*data$Y)/sum( (1-data$A)*data$w2) )
plot(data$w, data$w2, col=ifelse(data$A==1,'blue','gray'), xlim=c(0,10), ylim=c(0,10))
abline(0,1,col='red', lty=2)
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
hist(data$w, breaks=100, xlim=c(0,10))
#------------------------------------------------------------------------------#
###------ Implement weighted OLS estimator                             ------###
#------------------------------------------------------------------------------#
outcome_mod = lm(data=data, Y ~ A, weights = w)
summary(outcome_mod)
## note lm doesn't produce robust SEs - these SEs are therefore too narrow.
## can use vcovHC function in sandwich package to manually compute Robust SEs
library(sandwich)
sqrt( diag( vcovHC(outcome_mod) ) )
## finally, notw that using stabilized weights data$w2 rather than data$w in
## the lm() command generating outcome_mod does not change results.
## stabilization on has variance reduction abilities in *non-saturated* MSMs
#------------------------------------------------------------------------------#
###------ Use IPW Package                                              ------###
#------------------------------------------------------------------------------#
library(ipw) ## for ipwpoint function
plot(data$w, data$w2, col=ifelse(data$A==1,'blue','gray'), xlim=c(0,10), ylim=c(0,10))
abline(0,1,col='red', lty=2)
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
hist(data$w, breaks=100, xlim=c(0,10))
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
hist(data$w, breaks=100, xlim=c(0,10))
abline(v=1,col='red', lty=2)
plot(data$w, data$w2, col=ifelse(data$A==1,'blue','gray'), xlim=c(0,10), ylim=c(0,10))
abline(0,1,col='red', lty=2)
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
abline(v=1,col='red', lty=2)
hist(data$w, breaks=100, xlim=c(0,10))
abline(v=2,col='red', lty=2)
mean(data$w)
mean(data$w2)
plot(data$w, data$w2, col=ifelse(data$A==1,'blue','gray'), xlim=c(0,10), ylim=c(0,10))
abline(0,1,col='red', lty=2) ## line of equality
par(mfrow=c(2,1))
hist(data$w2, breaks=100, xlim=c(0,10))
abline(v=1,col='red', lty=2)
mean(data$w2)
hist(data$w, breaks=100, xlim=c(0,10))
abline(v=2,col='red', lty=2)
mean(data$w)
setwd("~/google_drive/Software/personal_site/")
?build_site
??build_site
blogdown::build_site()
