X=X, survt=dlist$time, delta=dlist$delta,
log_alpha=lalpha_shell )$x_0
# sample from conditional posterior of alpha: log_post_alpha
lalpha_shell <- metrop_hastings(x_0 = lalpha_shell,
iter = 1,
log_post_density = log_post_alpha,
prop_sigma = matrix(.005),
X=X, survt=dlist$time, delta=dlist$delta,
beta=beta_shell)$x_0
## sample from conditional posterior of missing survival times
# for(m in row_miss){
#   lambda_curr <- exp(-1*mu_curr[m]*alpha_curr)
#
#   survt_all[m] <- rtrunc(1, spec = 'weibull',
#                          a = survt[m],
#                          shape =  alpha_curr,
#                          scale =  lambda_curr)
# }
if(i>burnin){
mu_curr <-  X %*% beta_shell
alpha_curr <- exp(lalpha_shell)
## compute cost trajectories
mu_trt <-  sum(beta_shell[,1])
mu_pbo <-  beta_shell[1,1]
ddraw_trt <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_trt*alpha_curr)  )
ddraw_pbo <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_pbo*alpha_curr)  )
dstore_trt[i-burnin] <- ddraw_trt
dstore_pbo[i-burnin] <- ddraw_pbo
tot_time_trt <- min(c(tau, ddraw_trt) )
tot_time_pbo <- min(c(tau, ddraw_pbo) )
tseq_trt <- seq(0, tot_time_trt, step)
tseq_pbo <- seq(0, tot_time_pbo, step)
trajectory_trt <- exp(rnorm(n = length(tseq_trt),
mean = sum(theta_shell[1:2]) + theta_shell[3]*(tseq_trt),
sd = sqrt(phi_shell) ))
trajectory_pbo <- exp(rnorm(n = length(tseq_pbo),
mean = theta_shell[1] + theta_shell[3]*(tseq_pbo),
sd = sqrt(phi_shell) ))
tmat_trt[1:length(tseq_trt), i - burnin] <- trajectory_trt
tmat_pbo[1:length(tseq_pbo), i - burnin] <- trajectory_pbo
tmat_trt[, i - burnin] <- cumsum(tmat_trt[, i - burnin])
tmat_pbo[, i - burnin] <- cumsum(tmat_pbo[, i - burnin])
## store total costs
totcost_trt[i - burnin] <- tmat_trt[ tau, i - burnin]
totcost_pbo[i - burnin] <- tmat_pbo[ tau, i - burnin]
## store death time parameters
beta_store[,i-burnin] <- beta_shell[,1]
alpha_store[,i-burnin] <- exp(lalpha_shell)
}
if(i %% 100 == 0) print(i)
}
tau=10
n=1000
iter <- 2000
burnin <- 5000
step <-.1
set.seed(1)
dlist <- sim_dat_continuous(tau = tau, n = n)
source('~/Box Sync/Research/Analyses/BNP_CE/code/FunctionSourceCode.r')
dlist <- sim_dat_continuous(tau = tau, n = n)
survt_all <- dlist$time
survt <- dlist$time
X <- model.matrix(~ dlist$A)
# index for which rows are censored
row_miss <- c(1:n)[dlist$delta==0]
tt <- reshape2::melt(dlist$costmat, idvar = 1:n, direction = 'long')
tt <- tt[order(tt$Var1),]
colnames(tt) <- c('id','time','cost')
avar <- dlist$A
names(avar) <- 1:n
tt$A <- avar[as.character(tt$id)]
XM <- model.matrix(~ tt$A + tt$time)
XM <- XM[!is.na(tt$cost) & tt$cost!=0, ]
tt <- tt[!is.na(tt$cost) & tt$cost!=0, ]
phi_shell <- .01
beta_shell <- matrix(c(0,0), ncol = 1)
lalpha_shell <- .001
prop_covar <- diag(c(.1,.1))
tmat_trt <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, .1))) # nrow=length(seq(0,tau, .01))
tmat_pbo <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, .1)))
totcost_trt <- numeric(length = iter - burnin)
totcost_pbo <- numeric(length = iter - burnin)
dstore_trt <- numeric(length = iter - burnin)
dstore_pbo <- numeric(length = iter - burnin)
beta_store <- matrix(NA, ncol = iter-burnin, nrow=ncol(X))
alpha_store <- matrix(NA, ncol = iter-burnin, nrow=1)
step <- .1
source('~/Box Sync/Research/Analyses/BNP_CE/code/FunctionSourceCode.r')
tau=10
n=1000
iter <- 2000
burnin <- 5000
step <-.1
set.seed(1)
dlist <- sim_dat_continuous(tau = tau, n = n)
survt_all <- dlist$time
survt <- dlist$time
X <- model.matrix(~ dlist$A)
# index for which rows are censored
row_miss <- c(1:n)[dlist$delta==0]
tt <- reshape2::melt(dlist$costmat, idvar = 1:n, direction = 'long')
tt <- tt[order(tt$Var1),]
colnames(tt) <- c('id','time','cost')
avar <- dlist$A
names(avar) <- 1:n
tt$A <- avar[as.character(tt$id)]
XM <- model.matrix(~ tt$A + tt$time)
XM <- XM[!is.na(tt$cost) & tt$cost!=0, ]
tt <- tt[!is.na(tt$cost) & tt$cost!=0, ]
phi_shell <- .01
beta_shell <- matrix(c(0,0), ncol = 1)
lalpha_shell <- .001
prop_covar <- diag(c(.1,.1))
tmat_trt <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step))) # nrow=length(seq(0,tau, .01))
iter
burnin
iter <- 5000
burnin <- 2000
tmat_trt <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step))) # nrow=length(seq(0,tau, .01))
tmat_pbo <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step)))
totcost_trt <- numeric(length = iter - burnin)
totcost_pbo <- numeric(length = iter - burnin)
dstore_trt <- numeric(length = iter - burnin)
dstore_pbo <- numeric(length = iter - burnin)
beta_store <- matrix(NA, ncol = iter-burnin, nrow=ncol(X))
alpha_store <- matrix(NA, ncol = iter-burnin, nrow=1)
for(i in 1:iter){
# estimate model using all available data:
# y_i(t) = b0 + b1*A + b2*t + e,
# e ~ N(0, phi)
theta_shell <- rcond_post_beta(y = log(tt$cost),xm = XM, phi = phi_shell,
beta_prior_mean = c(0,0,0),
beta_prior_var = c(10,10,10)  )
phi_shell <- rcond_post_phi(beta = t(theta_shell),
y = log(tt$cost), xm = XM,
g1 = 3, b1 = 10)
# from conditional posterior of beta: log_post_beta
beta_shell[,1] <- metrop_hastings(x_0 = beta_shell,
iter = 1,
log_post_density = log_post_beta,
prop_sigma = prop_covar,
X=X, survt=dlist$time, delta=dlist$delta,
log_alpha=lalpha_shell )$x_0
# sample from conditional posterior of alpha: log_post_alpha
lalpha_shell <- metrop_hastings(x_0 = lalpha_shell,
iter = 1,
log_post_density = log_post_alpha,
prop_sigma = matrix(.005),
X=X, survt=dlist$time, delta=dlist$delta,
beta=beta_shell)$x_0
## sample from conditional posterior of missing survival times
# for(m in row_miss){
#   lambda_curr <- exp(-1*mu_curr[m]*alpha_curr)
#
#   survt_all[m] <- rtrunc(1, spec = 'weibull',
#                          a = survt[m],
#                          shape =  alpha_curr,
#                          scale =  lambda_curr)
# }
if(i>burnin){
mu_curr <-  X %*% beta_shell
alpha_curr <- exp(lalpha_shell)
## compute cost trajectories
mu_trt <-  sum(beta_shell[,1])
mu_pbo <-  beta_shell[1,1]
ddraw_trt <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_trt*alpha_curr)  )
ddraw_pbo <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_pbo*alpha_curr)  )
dstore_trt[i-burnin] <- ddraw_trt
dstore_pbo[i-burnin] <- ddraw_pbo
tot_time_trt <- min(c(tau, ddraw_trt) )
tot_time_pbo <- min(c(tau, ddraw_pbo) )
tseq_trt <- seq(0, tot_time_trt, step)
tseq_pbo <- seq(0, tot_time_pbo, step)
trajectory_trt <- exp(rnorm(n = length(tseq_trt),
mean = sum(theta_shell[1:2]) + theta_shell[3]*(tseq_trt),
sd = sqrt(phi_shell) ))
trajectory_pbo <- exp(rnorm(n = length(tseq_pbo),
mean = theta_shell[1] + theta_shell[3]*(tseq_pbo),
sd = sqrt(phi_shell) ))
tmat_trt[1:length(tseq_trt), i - burnin] <- trajectory_trt
tmat_pbo[1:length(tseq_pbo), i - burnin] <- trajectory_pbo
tmat_trt[, i - burnin] <- cumsum(tmat_trt[, i - burnin])
tmat_pbo[, i - burnin] <- cumsum(tmat_pbo[, i - burnin])
## store total costs
totcost_trt[i - burnin] <- tmat_trt[ tau, i - burnin]
totcost_pbo[i - burnin] <- tmat_pbo[ tau, i - burnin]
## store death time parameters
beta_store[,i-burnin] <- beta_shell[,1]
alpha_store[,i-burnin] <- exp(lalpha_shell)
}
if(i %% 100 == 0) print(i)
}
source('~/Box Sync/Research/Analyses/BNP_CE/code/FunctionSourceCode.r')
library(truncdist)
tau=10
n=1000
iter <- 5000
burnin <- 2000
step <-.1
set.seed(1)
dlist <- sim_dat_continuous(tau = tau, n = n)
survt_all <- dlist$time
survt <- dlist$time
X <- model.matrix(~ dlist$A)
# index for which rows are censored
row_miss <- c(1:n)[dlist$delta==0]
tt <- reshape2::melt(dlist$costmat, idvar = 1:n, direction = 'long')
tt <- tt[order(tt$Var1),]
colnames(tt) <- c('id','time','cost')
avar <- dlist$A
names(avar) <- 1:n
tt$A <- avar[as.character(tt$id)]
XM <- model.matrix(~ tt$A + tt$time)
XM <- XM[!is.na(tt$cost) & tt$cost!=0, ]
tt <- tt[!is.na(tt$cost) & tt$cost!=0, ]
phi_shell <- .01
beta_shell <- matrix(c(0,0), ncol = 1)
lalpha_shell <- .001
prop_covar <- diag(c(.1,.1))
tmat_trt <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step))) # nrow=length(seq(0,tau, .01))
tmat_pbo <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step)))
totcost_trt <- numeric(length = iter - burnin)
totcost_pbo <- numeric(length = iter - burnin)
dstore_trt <- numeric(length = iter - burnin)
dstore_pbo <- numeric(length = iter - burnin)
beta_store <- matrix(NA, ncol = iter-burnin, nrow=ncol(X))
alpha_store <- matrix(NA, ncol = iter-burnin, nrow=1)
for(i in 1:iter){
# estimate model using all available data:
# y_i(t) = b0 + b1*A + b2*t + e,
# e ~ N(0, phi)
theta_shell <- rcond_post_beta(y = log(tt$cost),xm = XM, phi = phi_shell,
beta_prior_mean = c(0,0,0),
beta_prior_var = c(10,10,10)  )
phi_shell <- rcond_post_phi(beta = t(theta_shell),
y = log(tt$cost), xm = XM,
g1 = 3, b1 = 10)
# from conditional posterior of beta: log_post_beta
beta_shell[,1] <- metrop_hastings(x_0 = beta_shell,
iter = 1,
log_post_density = log_post_beta,
prop_sigma = prop_covar,
X=X, survt=dlist$time, delta=dlist$delta,
log_alpha=lalpha_shell )$x_0
# sample from conditional posterior of alpha: log_post_alpha
lalpha_shell <- metrop_hastings(x_0 = lalpha_shell,
iter = 1,
log_post_density = log_post_alpha,
prop_sigma = matrix(.005),
X=X, survt=dlist$time, delta=dlist$delta,
beta=beta_shell)$x_0
## sample from conditional posterior of missing survival times
# for(m in row_miss){
#   lambda_curr <- exp(-1*mu_curr[m]*alpha_curr)
#
#   survt_all[m] <- rtrunc(1, spec = 'weibull',
#                          a = survt[m],
#                          shape =  alpha_curr,
#                          scale =  lambda_curr)
# }
if(i>burnin){
mu_curr <-  X %*% beta_shell
alpha_curr <- exp(lalpha_shell)
## compute cost trajectories
mu_trt <-  sum(beta_shell[,1])
mu_pbo <-  beta_shell[1,1]
ddraw_trt <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_trt*alpha_curr)  )
ddraw_pbo <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_pbo*alpha_curr)  )
dstore_trt[i-burnin] <- ddraw_trt
dstore_pbo[i-burnin] <- ddraw_pbo
tot_time_trt <- min(c(tau, ddraw_trt) )
tot_time_pbo <- min(c(tau, ddraw_pbo) )
tseq_trt <- seq(0, tot_time_trt, step)
tseq_pbo <- seq(0, tot_time_pbo, step)
trajectory_trt <- exp(rnorm(n = length(tseq_trt),
mean = sum(theta_shell[1:2]) + theta_shell[3]*(tseq_trt),
sd = sqrt(phi_shell) ))
trajectory_pbo <- exp(rnorm(n = length(tseq_pbo),
mean = theta_shell[1] + theta_shell[3]*(tseq_pbo),
sd = sqrt(phi_shell) ))
tmat_trt[1:length(tseq_trt), i - burnin] <- trajectory_trt
tmat_pbo[1:length(tseq_pbo), i - burnin] <- trajectory_pbo
tmat_trt[, i - burnin] <- cumsum(tmat_trt[, i - burnin])
tmat_pbo[, i - burnin] <- cumsum(tmat_pbo[, i - burnin])
## store total costs
totcost_trt[i - burnin] <- tmat_trt[ tau, i - burnin]
totcost_pbo[i - burnin] <- tmat_pbo[ tau, i - burnin]
## store death time parameters
beta_store[,i-burnin] <- beta_shell[,1]
alpha_store[,i-burnin] <- exp(lalpha_shell)
}
if(i %% 100 == 0) print(i)
}
tau=10
n=1000
iter <- 5000
burnin <- 2000
step <-.1
set.seed(1)
dlist <- sim_dat_continuous(tau = tau, n = n)
source('~/Box Sync/Research/Analyses/BNP_CE/code/FunctionSourceCode.r')
tau=10
n=1000
iter <- 5000
burnin <- 2000
step <-.1
set.seed(1)
dlist <- sim_dat_continuous(tau = tau, n = n)
survt_all <- dlist$time
survt <- dlist$time
X <- model.matrix(~ dlist$A)
# index for which rows are censored
row_miss <- c(1:n)[dlist$delta==0]
tt <- reshape2::melt(dlist$costmat, idvar = 1:n, direction = 'long')
tt <- tt[order(tt$Var1),]
colnames(tt) <- c('id','time','cost')
avar <- dlist$A
names(avar) <- 1:n
tt$A <- avar[as.character(tt$id)]
XM <- model.matrix(~ tt$A + tt$time)
XM <- XM[!is.na(tt$cost) & tt$cost!=0, ]
tt <- tt[!is.na(tt$cost) & tt$cost!=0, ]
phi_shell <- .01
beta_shell <- matrix(c(0,0), ncol = 1)
lalpha_shell <- .001
prop_covar <- diag(c(.1,.1))
tmat_trt <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step))) # nrow=length(seq(0,tau, .01))
tmat_pbo <- matrix(0,ncol = iter-burnin, nrow = length(seq(0,tau, step)))
totcost_trt <- numeric(length = iter - burnin)
totcost_pbo <- numeric(length = iter - burnin)
dstore_trt <- numeric(length = iter - burnin)
dstore_pbo <- numeric(length = iter - burnin)
beta_store <- matrix(NA, ncol = iter-burnin, nrow=ncol(X))
alpha_store <- matrix(NA, ncol = iter-burnin, nrow=1)
for(i in 1:iter){
# estimate model using all available data:
# y_i(t) = b0 + b1*A + b2*t + e,
# e ~ N(0, phi)
theta_shell <- rcond_post_beta(y = log(tt$cost),xm = XM, phi = phi_shell,
beta_prior_mean = c(0,0,0),
beta_prior_var = c(10,10,10)  )
phi_shell <- rcond_post_phi(beta = t(theta_shell),
y = log(tt$cost), xm = XM,
g1 = 3, b1 = 10)
# from conditional posterior of beta: log_post_beta
beta_shell[,1] <- metrop_hastings(x_0 = beta_shell,
iter = 1,
log_post_density = log_post_beta,
prop_sigma = prop_covar,
X=X, survt=dlist$time, delta=dlist$delta,
log_alpha=lalpha_shell )$x_0
# sample from conditional posterior of alpha: log_post_alpha
lalpha_shell <- metrop_hastings(x_0 = lalpha_shell,
iter = 1,
log_post_density = log_post_alpha,
prop_sigma = matrix(.005),
X=X, survt=dlist$time, delta=dlist$delta,
beta=beta_shell)$x_0
## sample from conditional posterior of missing survival times
# for(m in row_miss){
#   lambda_curr <- exp(-1*mu_curr[m]*alpha_curr)
#
#   survt_all[m] <- rtrunc(1, spec = 'weibull',
#                          a = survt[m],
#                          shape =  alpha_curr,
#                          scale =  lambda_curr)
# }
if(i>burnin){
mu_curr <-  X %*% beta_shell
alpha_curr <- exp(lalpha_shell)
## compute cost trajectories
mu_trt <-  sum(beta_shell[,1])
mu_pbo <-  beta_shell[1,1]
ddraw_trt <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_trt*alpha_curr)  )
ddraw_pbo <- rweibull(1, shape = alpha_curr,
scale = exp(-1*mu_pbo*alpha_curr)  )
dstore_trt[i-burnin] <- ddraw_trt
dstore_pbo[i-burnin] <- ddraw_pbo
tot_time_trt <- min(c(tau, ddraw_trt) )
tot_time_pbo <- min(c(tau, ddraw_pbo) )
tseq_trt <- seq(0, tot_time_trt, step)
tseq_pbo <- seq(0, tot_time_pbo, step)
trajectory_trt <- exp(rnorm(n = length(tseq_trt),
mean = sum(theta_shell[1:2]) + theta_shell[3]*(tseq_trt),
sd = sqrt(phi_shell) ))
trajectory_pbo <- exp(rnorm(n = length(tseq_pbo),
mean = theta_shell[1] + theta_shell[3]*(tseq_pbo),
sd = sqrt(phi_shell) ))
tmat_trt[1:length(tseq_trt), i - burnin] <- trajectory_trt
tmat_pbo[1:length(tseq_pbo), i - burnin] <- trajectory_pbo
tmat_trt[, i - burnin] <- cumsum(tmat_trt[, i - burnin])
tmat_pbo[, i - burnin] <- cumsum(tmat_pbo[, i - burnin])
## store total costs
totcost_trt[i - burnin] <- tmat_trt[ tau, i - burnin]
totcost_pbo[i - burnin] <- tmat_pbo[ tau, i - burnin]
## store death time parameters
beta_store[,i-burnin] <- beta_shell[,1]
alpha_store[,i-burnin] <- exp(lalpha_shell)
}
if(i %% 100 == 0) print(i)
}
par(mfrow=c(2,2))
hist(totcost_trt)
abline(v=mean(rowSums(dlist$costmat_true[dlist$A==1,] ) ), col='red', lwd=2)
hist(totcost_pbo)
abline(v=mean(rowSums(dlist$costmat_true[dlist$A==0,] ) ), col='red', lwd=2)
hist(rowSums(dlist$costmat_true[dlist$A==1,]))
hist(rowSums(dlist$costmat_true[dlist$A==0,]))
par(mfrow=c(2,2))
hist(totcost_trt)
abline(v=mean(rowSums(dlist$costmat_true[dlist$A==1,] ) ), col='red', lwd=2)
hist(totcost_pbo)
abline(v=mean(rowSums(dlist$costmat_true[dlist$A==0,] ) ), col='red', lwd=2)
hist(rowSums(dlist$costmat_true[dlist$A==1,]))
hist(rowSums(dlist$costmat_true[dlist$A==0,]))
hist(totcost_trt)
plot.new()
par(mfrow=c(1,2))
# hist(dstore_trt, breaks = 50)
# hist(dstore_pbo)
hist(c(dstore_trt, dstore_pbo), breaks=50)
hist(dlist$time[dlist$delta==1])
hist(dlist$time[dlist$delta==1])
5
par(mfrow=c(2,2))
hist(totcost_trt)
install.packages('vitae')
install.packages('rorcid')
library(dplyr)
?rorcid::orcid_educations
?rorcid::orcid_auth
orcid_aut()
library(rorcid)
orcid_aut()
orcid_auth()
?orcid_educations
Sys.setenv(ORCID_TOKEN="ca7a09cc-d723-4347-91e8-43e00b1732a4")
edu
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(vitae)
library(rorcid)
library(dplyr)
Sys.setenv(ORCID_TOKEN="ca7a09cc-d723-4347-91e8-43e00b1732a4")
edu <- rorcid::orcid_educations("0000-0002-0437-4611")
edu <- rorcid::orcid_educations("0000-0002-0437-4611")
edu
edu$`0000-0002-0437-4611`$`education-summary`$organization.address.country
edu$`0000-0002-0437-4611`$`education-summary`$organization.address.region
install.packages('scholar')
install.packages("scholar")
Y
ls
scholar::get_publications()
scholar::get_publications
?scholar::get_publications
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(vitae)
library(rorcid)
library(dplyr)
library(scholar)
Sys.setenv(ORCID_TOKEN="ca7a09cc-d723-4347-91e8-43e00b1732a4")
scholar::get_publications("ACzVmWYAAAAJ") %>%
detailed_entries(
what = title,
when = year,
with = author,
where = journal,
why = cites
)
pubs<-scholar::get_publications("ACzVmWYAAAAJ")
pubs$title
pubs$author
pubs$number
class(pubs)
scholar::get_publications("ACzVmWYAAAAJ") %>%
order_by(year) %>%
detailed_entries(
what = title,
when = year,
with = author,
where = journal
)
scholar::get_publications("ACzVmWYAAAAJ") %>%
order_by(year)
scholar::get_publications("ACzVmWYAAAAJ")
pubs$year
pubs <- scholar::get_publications("ACzVmWYAAAAJ")
pubs %>%
order_by(year)
pubs
year
?order_by
pubs %>%
arrange(year)
edu
edu$`0000-0002-0437-4611`$`education-summary`$start-`start-date.year.value`
edu$`0000-0002-0437-4611`$`education-summary`$start-`start-date.year.value`
edu$`0000-0002-0437-4611`$`education-summary`$`start-date.year.value`
?brief_entries
ls
setwd("Dropbox/personal_site/")
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
