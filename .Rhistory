eval_star = cond_post_beta1(par_star, shell$beta0, dlist,K)
eval_prev = cond_post_beta1(shell$beta1, shell$beta0, dlist,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$beta1 = par_star
}
## update beta0
par_star = as.numeric(mvtnorm::rmvnorm(1, shell$beta0, pcov_beta0 ) )
eval_star = cond_post_beta0(shell$beta1, par_star, dlist, shell$hp_beta,K)
eval_prev = cond_post_beta0(shell$beta1, shell$beta0, dlist, shell$hp_beta,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$beta0 = par_star
}
## update theta1
par_star = as.numeric(mvtnorm::rmvnorm(1, shell$theta1, pcov_theta1 ) )
eval_star = cond_post_theta1(par_star, shell$theta0, dlist,K)
eval_prev = cond_post_theta1(shell$theta1, shell$theta0, dlist,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$theta1 = par_star
}
## update theta0
par_star = as.numeric(mvtnorm::rmvnorm(1, shell$theta0, pcov_theta0 ) )
eval_star = cond_post_theta0(shell$theta1, par_star, dlist, shell$hp_theta,K)
eval_prev = cond_post_theta0(shell$theta1, shell$theta0, dlist, shell$hp_theta,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$theta0 = par_star
}
## update theta hyperpars
par_star = as.numeric(mvtnorm::rmvnorm(1, shell$hp_theta, pcov_hp_theta ) )
eval_star = cond_post_hp_theta(par_star, shell$theta0,K)
eval_prev = cond_post_hp_theta(shell$hp_theta, shell$theta0,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$hp_theta = par_star
}
## update beta hyperpars
par_star = as.numeric(mvtnorm::rmvnorm(1, shell$hp_beta, pcov_hp_beta ) )
eval_star = cond_post_hp_beta(par_star, shell$beta0,K)
eval_prev = cond_post_hp_beta(shell$hp_beta, shell$beta0,K)
aprob = min(1, exp( eval_star - eval_prev ) )
if(is.nan(aprob)) browser()
if( runif(1)< aprob ){
shell$hp_beta = par_star
}
#if( i %% 100==0 ) cat(paste0("mcmc: iteration ", i,"\n"))
if( (i >= burnin) & (i %% thin==0) ){
## store post-burnin draws
idx = (i - burnin)/thin + 1
store$beta0[ idx, ] = shell$beta0
store$beta1[idx, ] = shell$beta1
store$theta0[ idx, ] = shell$theta0
store$theta1[idx, ] = shell$theta1
store$hp_beta[ idx, ] = shell$hp_beta
store$hp_theta[idx, ] = shell$hp_theta
}
}
return(store)
}
N = 500
K=12
dlist = sim_dat(N,K,bsl_t, bsl_y)
library(dplyr)
library(tidyr)
library(LaplacesDemon)
dlist = sim_dat(N,K,bsl_t, bsl_y)
dlong = wide_to_long(dlist, 12, 500)
lm = glm(data=dlong, formula =
Yk ~ -1 + factor(k) + Ak + L.1+ L.2+ L.3+ L.4+ L.5,
family=poisson('log'))
pcov_theta0 = vcov(lm)[1:12, 1:12]
pcov_theta1 = vcov(lm)[13:18, 13:18]
lm = glm(data=dlong[dlong$k>1, ], formula =
Tk ~ -1 + factor(k) + Ak + L.1+ L.2+ L.3+ L.4+ L.5,
family=binomial('logit'))
pcov_beta0 = vcov(lm)[1:11, 1:11]
pcov_beta1 = vcov(lm)[12:17,12:17]
dlist2 = lapply(1:K, function(k){
Yk = dlong$Yk[dlong$k==k]
Tk = dlong$Tk[dlong$k==k]
Xk = as.matrix(cbind(dlong[dlong$k==k, c('Ak',paste0("L.",1:5)) ]))
return(list(Yk=Yk, Tk=Tk, Xk=Xk))
})
post_par_draws = switch_mcmc(dlist2, K=K,
.9*pcov_theta0,
.9*pcov_theta1,
.6*pcov_beta0,
.75*pcov_beta1,
10000, 1, 5000)
par(mfrow=c(4,3))
for(i in 1:12){
plot(theta0[,i], type='l')
abline(h=bsl_y[i], col='red')
}
keep = seq(1,5000, 5)
beta0 = post_par_draws$beta0[keep,]
beta1 = post_par_draws$beta1[keep,]
theta0 = post_par_draws$theta0[keep,]
theta1 = post_par_draws$theta1[keep,]
bsl_t = c(-4,-3,-2.5,-3,-4,-3,-2.5,-3,-4,-3,-2.5,-3)
bsl_y = c(0,1,2,1,0,1,2,1,0,1,2,1)
par(mfrow=c(4,3))
for(i in 1:12){
plot(theta0[,i], type='l')
abline(h=bsl_y[i], col='red')
}
par(mfrow=c(2,3))
for(i in 1:6){
plot(theta1[,i], type='l')
}
par(mfrow=c(4,3))
for(i in 1:11){
plot(beta0[,i], type='l')
abline(h=bsl_t[i], col='red')
}
par(mfrow=c(4,3))
for(i in 2:12){
plot(beta0[,i], type='l')
abline(h=bsl_t[i], col='red')
}
par(mfrow=c(4,3))
for(i in 1:11){
plot(beta0[,i], type='l')
abline(h=bsl_t[i+1], col='red')
}
par(mfrow=c(2,3))
for(i in 1:6){
plot(beta1[,i], type='l')
}
.256/2.37
.256/.04
.075/.43
.075/.043
1.37/1.42
.256/.043
.293/.00595
.293/2.33
.112/2.33
.006/2.33
1.42/1.37
.142/.131
.345/.051
2.5/2.13
2.5/2.25
6.41/6.34
.98/.96
.35/.07
.36/.07
x = rnorm(30)
shat = ssd(y)
shat = sd(y)
y = rnorm(30)
mhat = mean(y)
shat = sd(y)
mu_draw = rt(100000, n-1)*(shat/sqrt(n)) + mhat
n = 30
y = rnorm(30)
mhat = mean(y)
shat = sd(y)
mu_draw = rt(100000, n-1)*(shat/sqrt(n)) + mhat
hist(mu_draw)
hist(mu_draw), breaks=100)
hist(mu_draw, breaks=100)
mhat = mean(c(y,-20,20))
n_new = n + 2
mhat = mean(c(y,-20,20))
mhat
n = 30
y = rnorm(30)
mhat = mean(y)
shat = sd(y)
mu_draw = rt(100000, n-1)*(shat/sqrt(n)) + mhat
hist(mu_draw, breaks=100)
n_new = n + 2
mhat = mean(c(y,-20,20))
n = 30
y = rnorm(30)
mhat = mean(y)
shat = sd(y)
mu_draw = rt(100000, n-1)*(shat/sqrt(n)) + mhat
hist(mu_draw, breaks=100)
n_new = n + 2
mhat_new = mean(c(y,-20,20))
mhat_new
mhat
set.seed(1)
n = 30
y = rnorm(30)
mhat = mean(y)
shat = sd(y)
mu_draw = rt(100000, n-1)*(shat/sqrt(n)) + mhat
hist(mu_draw, breaks=100)
n_new = n + 2
mhat_new = mean(c(y,-20,20))
mhat_new
mhat
mhat_new = mean(c(y,mhat-20,mhat+20))
mhat_new
mhat
shat_new = sd(y_new)
y_new = c(y,mhat-20,mhat+20)
mhat_new = mean(y_new)
mhat_new
mhat
shat_new = sd(y_new)
shat_new
shat
mu_draw_new = rt(100000, n_new-1)*(shat_new/sqrt(n_new)) + shat_new
hist(mu_draw, breaks=100)
hist(mu_draw_new, breaks=100)
hist(rpois(10000, 1))
hist(rpois(10000, 0))
hist(rpois(10000, .000001))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .01))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, .1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
hist(rpois(10000, 1))
100000100
100000/1000
1000*52
2000*52
3000*52
3000*26
sim_dat = function(N=200, K=12, bsl_t, bsl_y , sim_int = NA){
cbar = matrix(0,nrow = N, ncol = K)
abar = matrix(nrow = N, ncol = K)
ybar = matrix(nrow = N, ncol = K)
tbar = matrix(nrow = N, ncol = K)
if(is.na( sim_int ) ){
abar[, 1] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
}else{
abar[, 1] = 1*( 1 >= sim_int )
}
tbar[, 1] = 0
cbar[, 1] = 0
ybar[, 1] = rpois(N, exp(bsl_y[1] + 1*abar[, 1] ) )
for(k in 2:K){
if(is.na(sim_int)){
abar[, k] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
abar[ abar[, k-1] == 1, k ] = 1
}else{
abar[, k] = 1 * ( k >= sim_int )
}
if(is.na(sim_int)){
cbar[, k] = rbern( N , invlogit( -2.5 ) )
}
tbar[, k] = rbern( N , invlogit( bsl_t[k] + 1*abar[, k]  ) )
ybar[, k] = rpois( N , exp(bsl_y[k] + 1*abar[, k]  ) )
tbar[ tbar[, k-1]==1, k ] = 1 ## dead stay dead
ybar[ tbar[, k-1]==1, k ] = 0  ## no events after death
}
## coarsen data
if(is.na(sim_int)){
cen_int = apply(cbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never censored
death_int = apply(tbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never died
censored = cen_int<= death_int & is.finite(cen_int) ## not equality - censoring happens before death
time = pmin(cen_int, death_int)
for(i in 1:N){
if(!censored[i]){
next
}else{
ybar[i, time[i]:K] = NA
tbar[i, time[i]:K] = NA
cbar[i, time[i]:K] = 1
}
}
}
if(is.na(sim_int)){
return(list(L=L, abar = abar, ybar = ybar, cbar=cbar, tbar=tbar ))
}else{
return( mean( rowSums(ybar) / (K - rowSums(tbar) ) ) )
}
}
rep(1,12)
sim_dat(N=300, K=12, bsl_t = rep(1,12), bsl_y = rep(1,12) )
library(LaplacesDemon)
tt = sim_dat(N=300, K=12, bsl_t = rep(1,12), bsl_y = rep(1,12),sim_int = 1 )
sim_dat = function(N=200, K=12, bsl_t, bsl_y , sim_int = NA){
cbar = matrix(0,nrow = N, ncol = K)
abar = matrix(nrow = N, ncol = K)
ybar = matrix(nrow = N, ncol = K)
tbar = matrix(nrow = N, ncol = K)
if(is.na( sim_int ) ){
abar[, 1] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
}else{
abar[, 1] = 1*( 1 >= sim_int )
}
tbar[, 1] = 0
cbar[, 1] = 0
ybar[, 1] = rpois(N, exp(bsl_y[1] + 1*abar[, 1] ) )
for(k in 2:K){
if(is.na(sim_int)){
abar[, k] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
abar[ abar[, k-1] == 1, k ] = 1
}else{
abar[, k] = 1 * ( k >= sim_int )
}
if(is.na(sim_int)){
cbar[, k] = rbern( N , invlogit( -2.5 ) )
}
tbar[, k] = rbern( N , invlogit( bsl_t[k] + 1*abar[, k]  ) )
ybar[, k] = rpois( N , exp(bsl_y[k] + 1*abar[, k]  ) )
tbar[ tbar[, k-1]==1, k ] = 1 ## dead stay dead
ybar[ tbar[, k-1]==1, k ] = 0  ## no events after death
}
## coarsen data
if(is.na(sim_int)){
cen_int = apply(cbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never censored
death_int = apply(tbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never died
censored = cen_int<= death_int & is.finite(cen_int) ## not equality - censoring happens before death
time = pmin(cen_int, death_int)
for(i in 1:N){
if(!censored[i]){
next
}else{
ybar[i, time[i]:K] = NA
tbar[i, time[i]:K] = NA
cbar[i, time[i]:K] = 1
}
}
}
return(list(L=L, abar = abar, ybar = ybar, cbar=cbar, tbar=tbar ))
}
tt = sim_dat(N=300, K=12, bsl_t = rep(1,12), bsl_y = rep(1,12),sim_int = 1 )
sim_dat = function(N=200, K=12, bsl_t, bsl_y , sim_int = NA){
cbar = matrix(0,nrow = N, ncol = K)
abar = matrix(nrow = N, ncol = K)
ybar = matrix(nrow = N, ncol = K)
tbar = matrix(nrow = N, ncol = K)
if(is.na( sim_int ) ){
abar[, 1] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
}else{
abar[, 1] = 1*( 1 >= sim_int )
}
tbar[, 1] = 0
cbar[, 1] = 0
ybar[, 1] = rpois(N, exp(bsl_y[1] + 1*abar[, 1] ) )
for(k in 2:K){
if(is.na(sim_int)){
abar[, k] = rbern(N, invlogit(-1 + L %*% Lcoeff_a ) )
abar[ abar[, k-1] == 1, k ] = 1
}else{
abar[, k] = 1 * ( k >= sim_int )
}
if(is.na(sim_int)){
cbar[, k] = rbern( N , invlogit( -2.5 ) )
}
tbar[, k] = rbern( N , invlogit( bsl_t[k] + 1*abar[, k]  ) )
ybar[, k] = rpois( N , exp(bsl_y[k] + 1*abar[, k]  ) )
tbar[ tbar[, k-1]==1, k ] = 1 ## dead stay dead
ybar[ tbar[, k-1]==1, k ] = 0  ## no events after death
}
## coarsen data
if(is.na(sim_int)){
cen_int = apply(cbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never censored
death_int = apply(tbar, 1, function(x) min(c(1:K)[x==1]) ) ## inf denotes never died
censored = cen_int<= death_int & is.finite(cen_int) ## not equality - censoring happens before death
time = pmin(cen_int, death_int)
for(i in 1:N){
if(!censored[i]){
next
}else{
ybar[i, time[i]:K] = NA
tbar[i, time[i]:K] = NA
cbar[i, time[i]:K] = 1
}
}
}
return(list(abar = abar, ybar = ybar, cbar=cbar, tbar=tbar ))
}
tt = sim_dat(N=300, K=12, bsl_t = rep(1,12), bsl_y = rep(1,12),sim_int = 1 )
View(tbar)
View(tt$tbar)
library(BayesCausalResearch,lib.loc = "Downloads/BayesCausalResearch/")
library('BayesCausalResearch',lib.loc = "Downloads/BayesCausalResearch/")
library('BayesCausalResearch', lib.loc = "~/Downloads/BayesCausalResearch/")
library('BayesCausalResearch', lib.loc = "~/Downloads/BayesCausalResearch/")
hist(plogis(rnorm(10000)))
hist((plogis(rnorm(10000))-.5)*2)
quantile((plogis(rnorm(10000))-.5)*2, probs=c(.025, .975))
library('BayesCausalResearch', lib.loc = "~/Downloads/BayesCausalResearch/")
install.packages("BayesCausalResearch", lib = "~/Downloads/BayesCausalResearch/")
library('BayesCausalResearch', lib.loc = "~/Downloads/")
install.packages("BayesCausalResearch", lib = "~/Downloads/")
install.packages("~/Downloads/BayesCausalResearch.zip", repos = NULL, type = "win.binary")
install.packages("BayesCausalResearch", lib = "~/Downloads/")
library('BayesCausalResearch', lib.loc = "~/Downloads/")
library(survival)
survival::aml
d = survival::aml
plot(survfit(Surv(d$time, d$status)~ d$x))
d = survival::solder
View(d)
hist(d$skips)
d = survival::cancer
View(d)
d = survival::cancer
d$status[d$status==1] = 0
plot(survfit(Surv(d$time, d$status)~ d$sex))
d$time = d$time/30
plot(survfit(Surv(d$time, d$status)~ d$sex))
30*12
30*30
library(discSurv)
d = d[,c('time','status','sex', 'age')]
d = survival::cancer
d$status[d$status==2] = 1
d$status[d$status==1] = 0
d$time = d$time/30
d$age = ( d$age - mean(d$age) )/ sd(d$age)
d = d[,c('time','status','sex', 'age')]
plot(survfit(Surv(d$time, d$status)~ d$sex))
d = survival::cancer
d$status[d$status==2] = 1
d$status[d$status==1] = 0
d$time = d$time/30
d$age = ( d$age - mean(d$age) )/ sd(d$age)
d = d[,c('time','status','sex', 'age')]
plot(survfit(Surv(d$time, d$status)~ d$sex))
d = survival::cancer
d$status[d$status==2] = 1
d = survival::cancer
d$status[d$status==2] = 1
d = survival::cancer
d$status[d$status==1] = 0
d$status[d$status==2] = 1
d$time = d$time/30
d$age = ( d$age - mean(d$age) )/ sd(d$age)
d = d[,c('time','status','sex', 'age')]
plot(survfit(Surv(d$time, d$status)~ d$sex))
K=30
Surv(d$time, d$status)
class(d$status[d$status==1] = 0)
class(Surv(d$time, d$status))
tt = Surv(d$time, d$status)
print(tt)
dim(tt)
tt[,1]
tt[,2]
class(Surv(d$time, d$status) ~ d$sex)
tt = Surv(d$time, d$status) ~ d$sex
tt
eval(tt)
methods(tt)
tt[1]
tt[2]
tt[3]
tt[4]
tt[1]
tt[2]
all.vars(tt)
vars = all.vars(formula)
## user inputs
formula = Surv(d$time, d$status) ~ d$sex
vars = all.vars(formula)
setwd("google_drive/Software/personal_site/")
blogdown::build_site()
